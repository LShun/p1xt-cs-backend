# Chapter 9 - Abstraction

## Introduction

In this lecture, I learned a slight bit about abstraction, which is to write less and get more.

## From Examples

In these lectures, I learned how to design abstract functions from two (or more) functions with repetitive code. I learned that as opposed to following down the How to Design Functions (HtDF) recipe, to design functions, we are going to go from the bottom to the top instead. This is because abstract functions gets harder and harder as it moves back in the HtDF recipe.

## Using Built In Abstract Functions

In these lectures, I learned how to use the built-in abstract functions while making my own functions. I learned how to recognize the correct built-in abstract function through the signatures and the comments of my program.

## Closures

In this lecture, I learned how to implement a function with closures. Basically, closures are functions that bound over locally defined variables or expressions. In other words, they "close over" them. According to [Wikipedia](https://en.wikipedia.org/wiki/Closure_(computer_programming)), closures allows the function to access those captured variables through the closure's copies of their values or references, even when the function is invoked outside their scope.

## Fold Functions

In this lecture, I learned how the fold function works and how to create an abstract fold function. I also learned how to create signatures for abstract functions with subfunctions or helpers in them.

## Practice Problems

Well, "Hard" problems are really challenging. Without any experience with abstraction, that function, which is supposed to take me 1 hour, took me a good 2 hours.

The main thing that helped with the design of the hard function, is to revisit back the previous lectures. Both the `fold functions` and the `practice problems` are especially helpful when solving the practice problems. Once I solved that, the Quiz coming up next is a piece of cake!